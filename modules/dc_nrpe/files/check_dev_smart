#!/usr/bin/env python
# 
# Check SMART status of all available hard drives
#
# This script can only be ran in DataCentred puppet environment as
# it relies on internal facts and binaries in our infrastructure.

import subprocess, sys, re

# Exit in expected format for nagios checks
def exit_program(code, message):
  sys.stdout.write(message + "\n")
  sys.exit(code)

# Run a shell command and return the output
def run_command(command):
  try:
    proc = subprocess.Popen(command.split(), stdout=subprocess.PIPE)
  except OSError:
    exit_program(3, "UNKNOWN: couldn't run " + command)
  return proc.stdout.read().rstrip()

# Returns true if a device is smart capable. False otherwise
def smart_capable(device):
  smartctl_output = run_command("smartctl -i " + device)
  result = re.findall("SMART support is: (.*)", smartctl_output)
  if result:
    if result[0] != 'Available - device has SMART capability.':
      return False
    if result[1] != 'Enabled':
      return False
  elif re.search("Device does not support SMART", smartctl_output):
    return False
  elif re.search("Device supports SMART and is Disabled", smartctl_output):
    return False
  else:
    exit_program(3, "UNKNOWN: unexpected output from smartctl -i " + device)
  return True
  
# Get the output from 'facter disks'
facter_output = run_command("facter disks")

# Make sure the fact actually exists
if facter_output == '':
  exit_program(3, "UNKNOWN: no fact about available disks")

# Get a list of all devices and transform the result into device files
devices = ["/dev/" + device_name for device_name in facter_output.split(',')]

# Make sure the node's disks have smart capability.
# If not, return an OK state so we don't get alerting
for device in devices:
  if "c0d0" in device or not smart_capable(device):
    exit_program(0, "OK: (unknown) device has no smart capability or it is disabled")

# This is a list of the smartctl output for each device
check_results = []

# Run the nagios core plugin check_ide_smart on each device
for device in devices:
  check_output = run_command ("/usr/lib/nagios/plugins/check_ide_smart -d " + device)
  # Append to the list of results
  check_results.append(check_output + " on device " + device)

# Status variables
state         = ''
code          = -1
no_tests      = 0
no_good_tests = 0 
no_fail_tests = 0
warning_devices = []
critical_devices = []

# We report a bad state if one or more report (WARNING|CRITICAL|UNKNOWN)
#
# Precedence rules: UNKNOWN > CRITICAL > WARNING > OK
#
# These rules mean that a higher precedence state will override the overall
# state regardless of the states of the other devices.
# 
# In the case of an unknown state returned from check_ide_smart, we still 
# return 2 (CRITICAL) code
# 
# The code tries to be smart and calculate the number of test failures.
# In case we get a bad return without number of tests, we immediately exit
# and report the result
for result in check_results:
  # Set the state and the code
  if "OK" in result:
    if state != "CRITICAL" and state != "UNKNOWN" and state != "WARNING":
      state = "OK"
      code = 0
    match = re.search(r"(\d+)/(\d+) tests passed", result)
    if match:
      no_good_tests += int(match.group(1))
      no_tests += int(match.group(2))
  elif "WARNING" in result:
    if state != "CRITICAL" and state != "UNKNOWN":
      state = "WARNING"
      code = 1
    match = re.search(r"(\d+)/(\d+) tests failed. on device (.+)", result)
    if match:
      no_fail_tests += int(match.group(1))
      no_tests += int(match.group(2))
    else:
      exit_program(code, result)
    warning_devices.append(match.group(3))
  elif "CRITICAL" in result:
    state = "CRITICAL"
    code = 2
    match = re.search(r"(\d+)/(\d+) tests failed. on device (.+)", result)
    if match:
      no_fail_tests += int(match.group(1))
      no_tests += int(match.group(2))
    else:
      exit_program(code, result)
    critical_devices.append(match.group(3))
  elif "UNKNOWN" in result: 
    exit_program(2, result)
  else:
    exit_program(2, "CRITICAL: check_ide_smart returned unknown status")

if state == "OK":
  service_status_line = "%s: Operational. (%s/%s tests passed) on all devices" \
                        % (state, no_good_tests, no_tests)
elif state == "WARNING":
  service_status_line = "%s: Harddrive Advisories Detected. %s/%s tests failed on devices: %s" \
                        % (state, no_fail_tests, no_tests, ",".join(warning_devices))
elif state == "CRITICAL":
  service_status_line = "%s: Harddrive PreFailures Detected. %s/%s tests failed on devices: %s" \
                        % (state, no_fail_tests, no_tests, ",".join(critical_devices))
elif state == "UNKNOWN": 
  service_status_line = "CRITICAL: One or more devices reported unknown state"

exit_program(code, service_status_line)

