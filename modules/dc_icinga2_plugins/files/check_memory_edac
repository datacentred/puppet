#!/usr/bin/env python
"""
Checks for EDAC Memory Errors

The module checks that the EDAC driver is supported then interrogates each
memory controller, chip-select row and channel.  Initially it only looks
for correctable errors and triggers a warning.
"""

import glob
import os
import re
import sys

NAGIOS_OK = 0
NAGIOS_WARNING = 1
NAGIOS_CRITICAL = 2
NAGIOS_UNKNOWN = 3

EDAC_DIR = '/sys/devices/system/edac/mc'

def format_output(controller, channel, select, errors):
    """Translates the raw sysfs parameters into a human readable form"""

    # Translate controller and channel to indexed from 1 and translate the
    # channel select to be indexed from A.  This is SuperMicro formatting
    controller = controller + 1
    channel = channel + 1
    select = chr(select + ord('A'))

    return 'CPU{} DIMM-{}{}={}'.format(controller, channel, select, errors)


def main():
    """Probes sysfs for EDAC errors and reports them"""

    # Check for edac support and ignore the check if not supported
    if not os.access(EDAC_DIR, os.F_OK):
        print 'OK: no edac support detected'
        sys.exit(NAGIOS_OK)

    code = NAGIOS_OK
    dimms = []

    # Get a list of all relevant files
    ce_files = glob.glob(EDAC_DIR + '/mc*/csrow*/ch*_ce_count')
    for ce_file in ce_files:

        # Read the correctable errors
        with open(ce_file) as ce_file_fd:
            errors = int(ce_file_fd.read())

            # Buffer the ouput
            matches = re.search(r'mc(\d+)/csrow(\d+)/ch(\d+)_ce_count', ce_file)
            controller = int(matches.group(1))
            select = int(matches.group(2))
            channel = int(matches.group(3))
            dimms.append(format_output(controller, select, channel, errors))

            # Error detected, mark this DIMM may fail
            if errors:
                code = NAGIOS_WARNING

    status = ['OK', 'WARNING', 'CRITICAL'][code]
    print status + ': ' + ', '.join(dimms)
    sys.exit(code)


if __name__ == '__main__':
    main()

# vi: ts=4 et:
