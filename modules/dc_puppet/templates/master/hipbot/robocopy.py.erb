"""
Robocopy

Plugin responsible for synchronising the local git mirror with github,
pulling the changes into the production environment, and synching the
classes with foreman
"""

from HTMLParser import HTMLParser
import logging
import re
import subprocess
import random
import urllib2
import json
import threading
import Queue
import base64
import time
import glob
import os

DOMAIN       = '<%= @domain %>'
FOREMAN_HOST = '<%= @foreman_url %>'
FOREMAN_USER = 'admin'
FOREMAN_PASS = '<%= @foreman_admin_pw %>'

# A queue to store requests
queue = Queue.Queue()
branches = []
coalesce_size = 0
faux_branch_name = 'not_a_real_branch'

class MLStripper(HTMLParser):
    """
    Strips all the HTML tags out of a string
    """

    def __init__(self):
        """
        Initialization
        """
        self.reset()
        self.fed = []

    def handle_data(self, data):
        """
        Data, bits on in tags get appended to the list
        """
        self.fed.append(data)

    def handle_entityref(self, ref):
        """
        Hopefully you don't have &amp; and stuff in your username
        or branch titles!!
        """
        logging.warning('[GitBot] warning unhandled entity reference ' + ref)

    def get_data(self):
        """
        Concatenate all the data to get a single string
        """
        return ''.join(self.fed)

##############################################################################
# My Little Pony: Friendship Is Magic
##############################################################################

def get_image(vhost):
    """Return a random image"""
    path = 'http://' + vhost + '.' + DOMAIN + '/'
    resp = urllib2.urlopen(path + vhost + '.json')
    images = json.loads(resp.read())
    return path + random.choice(images)

def get_pony():
    """Return a random pony"""
    return get_image('ponies')

def get_scarlett():
    """Return a random Scarlett"""
    return get_image('puppies')

##############################################################################
# Git
##############################################################################

def git_run(command):
    """Run a command as the git user"""
    rc = subprocess.call(['sudo', '-H', '-u', 'git', 'bash', '-c', command])
    if rc != 0:
        be.send_message('<b>Git Consistency Error</b><br />' \
            'Exit code ' + '{0}'.format(rc) + ' performing<br />' \
            '<em>' + command + '</em>', 'red')
        raise RuntimeError

def git_sync():
    """Synchronise repos and submodules"""
    popd = os.getcwd()
    try:
        # Become the git user and fetch the production branch, this
        # is a bare repository so we need to fast forward the destination
        # reference to that of the source
        os.chdir('/home/git/puppet.git')
        git_run('git fetch origin master:master')

        # Likewise mirror changes to the puppet environment
        os.chdir('/etc/puppet/environments/production')
        git_run('git pull')
        git_run('git submodule init')
        git_run('git submodule sync')
        git_run('git submodule update')
    except RuntimeError:
        raise
    finally:
        os.chdir(popd)

def git_delete(branch):
    """Delete a branch and kill off the dynamic environment"""
    popd = os.getcwd()
    try:
        os.chdir('/home/git/puppet.git')
        git_run('git branch -D {0}'.format(branch))
        git_run('git push origin :{0}'.format(branch))
        git_run('rm -rf /etc/puppet/environments/{0}'.format(branch))
    except RuntimeError:
        raise
    finally:
        os.chdir(popd)

def git_resolve_branch(branch):
    """Resolve the true branch name from what hipchat spits out"""
    match = re.match(r'(.*)[\.]{3}$', branch)
    if match == None:
        return branch
    dirs = glob.glob('/etc/puppet/environments/{0}*'.format(match.group(1)))
    if len(dirs) != 1:
        logging.warning('[Git] Multiple matches for {0}'.format(branch))
        return 'ambiguous_branch_name'
    return os.path.basename(dirs[0])

##############################################################################
# Foreman
##############################################################################

def foreman_get(path):
    """GET from the foreman"""
    url = 'https://{0}.{1}{2}'.format(FOREMAN_HOST, DOMAIN, path)
    request = urllib2.Request(url)
    # Add in the plain-text authorization header
    auth = base64.encodestring("{0}:{1}".format(FOREMAN_USER, FOREMAN_PASS))
    request.add_header('Authorization', 'Basic {0}'.format(auth))
    # May raise urllib2.URLError
    while True:
        try:
            response = urllib2.urlopen(request)
        except:
            be.send_message('<b>Foreman API Error</b><br />' \
                'Retrying in 60s ...', 'red')
            logging.warning("[Worker] HTTP GET exception")
            time.sleep(60)
        else:
            break
    return response.read()

def foreman_post(path, post):
    """POST to the foreman"""
    url = 'https://{0}.{1}{2}'.format(FOREMAN_HOST, DOMAIN, path)
    request = urllib2.Request(url)
    # Add in the plain-text authorization header
    auth = base64.encodestring("{0}:{1}".format(FOREMAN_USER, FOREMAN_PASS))
    request.add_header('Authorization', 'Basic {0}'.format(auth))
    # May raise urllib2.URLError
    while True:
        try:
            response = urllib2.urlopen(request, post)
        except:
            be.send_message('<b>Foreman API Error</b><br />' \
                'Retrying in 60s ...', 'red')
            logging.warning("[Worker] HTTP PUT exception")
            time.sleep(60)
        else:
            break
    return response.read()

def get_smart_proxy_id(name):
    """Given the textual name lookup a smart proxy"""
    resp = foreman_get('/api/smart_proxies')
    data = json.loads(resp)
    for proxy in data:
        if proxy['smart_proxy']['name'] == name:
            return proxy['smart_proxy']['id']
    logging.info('[Worker] smart proxy exception: ' + url)
    raise Exception

def get_environment_id(name):
    """Given the textual name lookup an environment"""
    resp = foreman_get('/api/environments')
    data = json.loads(resp)
    for environment in data:
        if environment['environment']['name'] == name:
            return environment['environment']['id']
    logging.info('[Worker] environment exception: ' + url)
    raise Exception

def post_update_puppetclasses(proxy, env):
    """Update all puppet classes for the specified environment"""
    path = '/api/smart_proxies/{0}/import_puppetclasses'.format(proxy)
    data = 'environment_id={0}'.format(env)
    foreman_post(path, data)

def foreman_sync():
    """Import all puppet classes from the master's production env"""
    proxy = get_smart_proxy_id('Puppet Master')
    env = get_environment_id('production')
    post_update_puppetclasses(proxy, env)

##############################################################################
# Utilities
##############################################################################

lock = threading.Lock()

def enqueue_job(branch):
    """Add a branch merge to the job queue(s)"""
    lock.acquire()
    branches.append(branch)
    lock.release()
    queue.put(0)

def wait_job():
    """Wait for a job to become available"""
    global coalesce_size
    global start_time
    queue.get()
    # Dequeue as many jobs as possible and merge
    # into a single synchronisation
    lock.acquire()
    coalesce_size = 1
    while True:
        try:
            queue.get(False)
        except Queue.Empty:
            break
        coalesce_size += 1
    lock.release()
    start_time = time.time()

def dequeue_job():
    """Remove the job(s) from the job queue(s)"""
    global coalesce_size
    end_time = time.time()
    delta = end_time - start_time
    lock.acquire()
    message = "<b>Foreman Class Import</b><br />"
    message += "<em>Completed in {0:.2f}s</em><br />".format(delta)
    message += "The following branches are now live<br />"
    for environment in branches[:coalesce_size]:
        message += "&#9656; {0}<br />".format(environment)
    be.send_message(message, 'green')
    # Pop and ack all the jobs we coalesced
    for temp in range(coalesce_size):
        branches.pop(0)
        queue.task_done()
    coalesce_size = 0
    lock.release()

def report_git_sync():
    """Report that your classes are synced with puppet"""
    lock.acquire()
    message = "<b>Puppet Class Sync</b><br />"
    message += "The following branches are now live<br />"
    for environment in branches[:coalesce_size]:
        message += "&#9656; {0}<br />".format(environment)
    be.send_message(message, 'green')
    lock.release()

def kill_environment():
    """Kill off a dynamic environment"""
    lock.acquire()
    for environment in branches[:coalesce_size]:
        if environment != faux_branch_name:
            git_delete(environment)
    lock.release()

def dump_queue():
    """Print out the current job queue status"""
    # Multi line input must be given via /quote
    # or the newlines will be ignored
    output = "<b>Job Queue</b><br />"
    if coalesce_size:
        end_time = time.time()
        delta = end_time - start_time
        output += "<em>Current runtime {0:.2f}s</em><br />".format(delta)
    lock.acquire()
    for i in branches[:coalesce_size]:
        output += "{0} (<em>running</em>)<br />".format(i)
    for i in branches[coalesce_size:]:
        output += "{0}<br />".format(i)
    lock.release()
    return output

##############################################################################
# Updater thread
##############################################################################

def worker_main(*args, **kwargs):
    """
    As we can have multiple pull requests happen at once
    we process them asynchronously in this thread to ensure
    that both foreman and the puppet repos are totally in sync
    with GitHub
    """
    logging.info('[Worker] started child')
    while True:
        logging.info('[Worker] wait queue')
        wait_job()
        try:
            logging.info('[Worker] deleting dynamic environment')
            kill_environment()
            logging.info('[Worker] syncing git')
            git_sync()
            report_git_sync()
            logging.info('[Worker] syncing foreman')
            foreman_sync()
        except RuntimeError:
            pass
        # Always dequeue to prevent infinite spam
        logging.info('[Worker] sync complete')
        dequeue_job()

##############################################################################
# Actual HipBot plugin!
##############################################################################

class RoboCopy():
    """Main Robocopy plugin to interact with HipBot"""

    def __init__(self, backend):
        """Constructor"""
        global be
        self.backend = backend
        be = backend
        worker = threading.Thread(target=worker_main)
        worker.daemon = True
        worker.start()

    def __del__(self):
        """Destructor"""
        queue.join()

    def message(self, msg):
        """
        Process incoming messages and take any action that is required
        """
        # Remove all the markup from the body to allow easier parsing
        stripper = MLStripper()
        stripper.feed(msg)

        # Okay so we could be a bit fuzzier, this will break first :)
        match = re.match(r'\S+ pushed to branch master of datacentred/puppet' \
                         r' - Merge pull request #(\d+) from datacentred/(\S+)',
                         stripper.get_data())

        if match != None:
            # Provide visual feed back in the channel that we're
            # actually doing something.  Ponies are good for this
            self.backend.send_message("<b>Branch Merged</b><br />" \
                "Enqueuing clean up and synchronisation for pull request " \
                + match.group(1) + "<br />", 'yellow')
            enqueue_job(git_resolve_branch(match.group(2)))

    def queue(self, msg):
        """Interrogate the run queue"""
        self.backend.send_message(dump_queue(), 'yellow')
        pass

    def sync(self, msg):
        """Print a pony and sync the repos explicitly"""
        enqueue_job(faux_branch_name)

    def pony(self, msg):
        """Print a pony! And test the daemon obviously"""
        self.backend.send_message("<b>Ponies!!</b><br />" \
            "<img src=\"" + get_pony() + "\"></img>", 'random')
    
    def scarlett(self, msg):
        """Echo out a Scarlett Johansson"""
        self.backend.send_message("<b>Scarlett Johansson</b><br />" \
            "<img src=\"" + get_scarlett() + "\"></img>", 'red')

# vim: set syntax=python ts=4 et:
